import { parse } from "marked";

const markdownDir = Deno.readDirSync("markdown");

type ContentMeta = {
  "title-en": string;
  "title-id": string;
  tags: string[];
  thumbnail: string;
  date: string;
  "summary-en"?: string;
  "summary-id"?: string;
  cover?: string;
};



function getLastPath(input: string): string {
  const splitted = input.split("/");

  return splitted.pop() || "";
}

function readMdDirRecursive(
  root: Iterable<Deno.DirEntry>,
  path: string,
  objects: Record<string, unknown>,
) {
  for (const file of root) {
    const newPath = `${path}/${file.name}`;

    if (file.isDirectory) {
      const newRoot = Deno.readDirSync(newPath);
      const newBuff = {};
      readMdDirRecursive(newRoot, newPath, newBuff);
      objects[getLastPath(newPath)] = newBuff;
    }

    if (file.isFile) {
      const md = Deno.readTextFileSync(newPath);
      if (newPath.endsWith(".md")) {
        const html = parse(md, {
          gfm: true,
          breaks: false,
        });
        objects[getLastPath(newPath)] = html;
      } else if (newPath.endsWith(".json")) {
        objects[getLastPath(newPath)] = JSON.parse(md);
      }
    }
  }
  return objects;
}

const buff = {};
readMdDirRecursive(markdownDir, "markdown", buff);

const markdownContentAsTypescript = JSON.stringify(buff, null, 2);
const content = /*typescript*/ `
// This file is generated by bin/converter.ts Please do not update this file directly


export type ContentMeta = {    
    "title-en": string;
    "title-id": string;
    tags: string[];
    thumbnail: string;
    date: string;
    "summary-en"?: string;
    "summary-id"?: string;
    cover?: string
}

export type Content = {
    blog: {
        id: Record<string, string>
        en: Record<string, string>
        meta: Record<string, ContentMeta>
    }
    "about-en.md": string
    "about-id.md": string
}


export const markdownContents: Content = ${markdownContentAsTypescript}
`;
Deno.writeTextFile("generated/html.ts", content);
